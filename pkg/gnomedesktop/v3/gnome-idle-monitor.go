// Code generated by girgen. DO NOT EDIT.

package gnomedesktop

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gnomedesktop3_IdleMonitorWatchFunc(GnomeIdleMonitor*, guint, gpointer);
import "C"

// GType values.
var (
	GTypeIdleMonitor = coreglib.Type(C.gnome_idle_monitor_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeIdleMonitor, F: marshalIdleMonitor},
	})
}

type IdleMonitorWatchFunc func(monitor *IdleMonitor, id uint)

// IdleMonitorOverrides contains methods that are overridable.
type IdleMonitorOverrides struct {
}

func defaultIdleMonitorOverrides(v *IdleMonitor) IdleMonitorOverrides {
	return IdleMonitorOverrides{}
}

type IdleMonitor struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.Initable
}

var (
	_ coreglib.Objector = (*IdleMonitor)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*IdleMonitor, *IdleMonitorClass, IdleMonitorOverrides](
		GTypeIdleMonitor,
		initIdleMonitorClass,
		wrapIdleMonitor,
		defaultIdleMonitorOverrides,
	)
}

func initIdleMonitorClass(gclass unsafe.Pointer, overrides IdleMonitorOverrides, classInitFunc func(*IdleMonitorClass)) {
	if classInitFunc != nil {
		class := (*IdleMonitorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapIdleMonitor(obj *coreglib.Object) *IdleMonitor {
	return &IdleMonitor{
		Object: obj,
		Initable: gio.Initable{
			Object: obj,
		},
	}
}

func marshalIdleMonitor(p uintptr) (interface{}, error) {
	return wrapIdleMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - idleMonitor: new IdleMonitor that tracks the server-global idletime for
//     all devices.
//
func NewIdleMonitor() *IdleMonitor {
	var _cret *C.GnomeIdleMonitor // in

	_cret = C.gnome_idle_monitor_new()

	var _idleMonitor *IdleMonitor // out

	_idleMonitor = wrapIdleMonitor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _idleMonitor
}

// The function takes the following parameters:
//
//   - intervalMsec: idletime interval, in milliseconds. It must be a strictly
//     positive value (> 0).
//   - callback (optional) to call when the user has accumulated interval_msec
//     milliseconds of idle time.
//
// The function returns the following values:
//
//   - guint: watch id
//
//     Adds a watch for a specific idle time. The callback will be called
//     when the user has accumulated interval_msec milliseconds of idle time.
//     This function will return an ID that can either be passed to
//     gnome_idle_monitor_remove_watch(), or can be used to tell idle time
//     watches apart if you have more than one.
//
//     Also note that this function will only care about positive
//     transitions (user's idle time exceeding a certain time).
//     If you want to know about when the user has become active, use
//     gnome_idle_monitor_add_user_active_watch().
//
func (monitor *IdleMonitor) AddIdleWatch(intervalMsec uint64, callback IdleMonitorWatchFunc) uint {
	var _arg0 *C.GnomeIdleMonitor         // out
	var _arg1 C.guint64                   // out
	var _arg2 C.GnomeIdleMonitorWatchFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify
	var _cret C.guint // in

	_arg0 = (*C.GnomeIdleMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	_arg1 = C.guint64(intervalMsec)
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gnomedesktop3_IdleMonitorWatchFunc)
		_arg3 = C.gpointer(gbox.Assign(callback))
		_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	_cret = C.gnome_idle_monitor_add_idle_watch(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(intervalMsec)
	runtime.KeepAlive(callback)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function takes the following parameters:
//
//   - callback (optional) to call when the user is active again.
//
// The function returns the following values:
//
//   - guint: watch id
//
//     Add a one-time watch to know when the user is active again. Note that
//     this watch is one-time and will de-activate after the function is called,
//     for efficiency purposes. It's most convenient to call this when an idle
//     watch, as added by gnome_idle_monitor_add_idle_watch(), has triggered.
//
func (monitor *IdleMonitor) AddUserActiveWatch(callback IdleMonitorWatchFunc) uint {
	var _arg0 *C.GnomeIdleMonitor         // out
	var _arg1 C.GnomeIdleMonitorWatchFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret C.guint // in

	_arg0 = (*C.GnomeIdleMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	if callback != nil {
		_arg1 = (*[0]byte)(C._gotk4_gnomedesktop3_IdleMonitorWatchFunc)
		_arg2 = C.gpointer(gbox.Assign(callback))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	_cret = C.gnome_idle_monitor_add_user_active_watch(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(callback)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint64: current idle time, in milliseconds.
//
func (monitor *IdleMonitor) Idletime() uint64 {
	var _arg0 *C.GnomeIdleMonitor // out
	var _cret C.guint64           // in

	_arg0 = (*C.GnomeIdleMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gnome_idle_monitor_get_idletime(_arg0)
	runtime.KeepAlive(monitor)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// RemoveWatch removes an idle time watcher, previously
// added by gnome_idle_monitor_add_idle_watch() or
// gnome_idle_monitor_add_user_active_watch().
//
// The function takes the following parameters:
//
//   - id: watch ID.
//
func (monitor *IdleMonitor) RemoveWatch(id uint) {
	var _arg0 *C.GnomeIdleMonitor // out
	var _arg1 C.guint             // out

	_arg0 = (*C.GnomeIdleMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	_arg1 = C.guint(id)

	C.gnome_idle_monitor_remove_watch(_arg0, _arg1)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(id)
}

// IdleMonitorClass: instance of this type is always passed by reference.
type IdleMonitorClass struct {
	*idleMonitorClass
}

// idleMonitorClass is the struct that's finalized.
type idleMonitorClass struct {
	native *C.GnomeIdleMonitorClass
}
