// Code generated by girgen. DO NOT EDIT.

package gnomedesktop

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// extern void _gotk4_gnomedesktop3_BGCrossfade_ConnectFinished(gpointer, GObject*, guintptr);
// extern void _gotk4_gnomedesktop3_BGCrossfadeClass_finished(GnomeBGCrossfade*, GdkWindow*);
// void _gotk4_gnomedesktop3_BGCrossfade_virtual_finished(void* fnptr, GnomeBGCrossfade* arg0, GdkWindow* arg1) {
//   ((void (*)(GnomeBGCrossfade*, GdkWindow*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeBGCrossfade = coreglib.Type(C.gnome_bg_crossfade_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBGCrossfade, F: marshalBGCrossfade},
	})
}

// BGCrossfadeOverrides contains methods that are overridable.
type BGCrossfadeOverrides struct {
	// The function takes the following parameters:
	//
	Finished func(window gdk.Windower)
}

func defaultBGCrossfadeOverrides(v *BGCrossfade) BGCrossfadeOverrides {
	return BGCrossfadeOverrides{
		Finished: v.finished,
	}
}

type BGCrossfade struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*BGCrossfade)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*BGCrossfade, *BGCrossfadeClass, BGCrossfadeOverrides](
		GTypeBGCrossfade,
		initBGCrossfadeClass,
		wrapBGCrossfade,
		defaultBGCrossfadeOverrides,
	)
}

func initBGCrossfadeClass(gclass unsafe.Pointer, overrides BGCrossfadeOverrides, classInitFunc func(*BGCrossfadeClass)) {
	pclass := (*C.GnomeBGCrossfadeClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeBGCrossfade))))

	if overrides.Finished != nil {
		pclass.finished = (*[0]byte)(C._gotk4_gnomedesktop3_BGCrossfadeClass_finished)
	}

	if classInitFunc != nil {
		class := (*BGCrossfadeClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBGCrossfade(obj *coreglib.Object) *BGCrossfade {
	return &BGCrossfade{
		Object: obj,
	}
}

func marshalBGCrossfade(p uintptr) (interface{}, error) {
	return wrapBGCrossfade(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectFinished: when a crossfade finishes, window will have a copy of the
// end surface as its background, and this signal will get emitted.
func (fade *BGCrossfade) ConnectFinished(f func(window *coreglib.Object)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(fade, "finished", false, unsafe.Pointer(C._gotk4_gnomedesktop3_BGCrossfade_ConnectFinished), f)
}

// NewBGCrossfade creates a new object to manage crossfading a window background
// between two #cairo_surface_ts.
//
// The function takes the following parameters:
//
//   - width of the crossfading window.
//   - height of the crossfading window.
//
// The function returns the following values:
//
//   - bgCrossfade: new BGCrossfade.
//
func NewBGCrossfade(width, height int) *BGCrossfade {
	var _arg1 C.int               // out
	var _arg2 C.int               // out
	var _cret *C.GnomeBGCrossfade // in

	_arg1 = C.int(width)
	_arg2 = C.int(height)

	_cret = C.gnome_bg_crossfade_new(_arg1, _arg2)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _bgCrossfade *BGCrossfade // out

	_bgCrossfade = wrapBGCrossfade(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bgCrossfade
}

// IsStarted: this function reveals whether or not fade is currently running on
// a window. See gnome_bg_crossfade_start() for information on how to initiate a
// crossfade.
//
// The function returns the following values:
//
//   - ok: TRUE if fading, or FALSE if not fading.
//
func (fade *BGCrossfade) IsStarted() bool {
	var _arg0 *C.GnomeBGCrossfade // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GnomeBGCrossfade)(unsafe.Pointer(coreglib.InternObject(fade).Native()))

	_cret = C.gnome_bg_crossfade_is_started(_arg0)
	runtime.KeepAlive(fade)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetEndSurface: before initiating a crossfade with gnome_bg_crossfade_start()
// a start and end surface have to be set. This function sets the surface shown
// at the end of the crossfade effect.
//
// The function takes the following parameters:
//
//   - surface: cairo surface to fade to.
//
// The function returns the following values:
//
//   - ok: TRUE if successful, or FALSE if the surface could not be copied.
//
func (fade *BGCrossfade) SetEndSurface(surface *cairo.Surface) bool {
	var _arg0 *C.GnomeBGCrossfade // out
	var _arg1 *C.cairo_surface_t  // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GnomeBGCrossfade)(unsafe.Pointer(coreglib.InternObject(fade).Native()))
	_arg1 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))

	_cret = C.gnome_bg_crossfade_set_end_surface(_arg0, _arg1)
	runtime.KeepAlive(fade)
	runtime.KeepAlive(surface)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetStartSurface: before initiating a crossfade with
// gnome_bg_crossfade_start() a start and end surface have to be set. This
// function sets the surface shown at the beginning of the crossfade effect.
//
// The function takes the following parameters:
//
//   - surface: cairo surface to fade from.
//
// The function returns the following values:
//
//   - ok: TRUE if successful, or FALSE if the surface could not be copied.
//
func (fade *BGCrossfade) SetStartSurface(surface *cairo.Surface) bool {
	var _arg0 *C.GnomeBGCrossfade // out
	var _arg1 *C.cairo_surface_t  // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GnomeBGCrossfade)(unsafe.Pointer(coreglib.InternObject(fade).Native()))
	_arg1 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))

	_cret = C.gnome_bg_crossfade_set_start_surface(_arg0, _arg1)
	runtime.KeepAlive(fade)
	runtime.KeepAlive(surface)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start: this function initiates a quick crossfade between two surfaces
// on the background of window. Before initiating the crossfade both
// gnome_bg_crossfade_start() and gnome_bg_crossfade_end() need to be called. If
// animations are disabled, the crossfade is skipped, and the window background
// is set immediately to the end surface.
//
// The function takes the following parameters:
//
//   - window to draw crossfade on.
//
func (fade *BGCrossfade) Start(window gdk.Windower) {
	var _arg0 *C.GnomeBGCrossfade // out
	var _arg1 *C.GdkWindow        // out

	_arg0 = (*C.GnomeBGCrossfade)(unsafe.Pointer(coreglib.InternObject(fade).Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gnome_bg_crossfade_start(_arg0, _arg1)
	runtime.KeepAlive(fade)
	runtime.KeepAlive(window)
}

// Stop: this function stops any in progress crossfades that may be happening.
// It's harmless to call this function if fade is already stopped.
func (fade *BGCrossfade) Stop() {
	var _arg0 *C.GnomeBGCrossfade // out

	_arg0 = (*C.GnomeBGCrossfade)(unsafe.Pointer(coreglib.InternObject(fade).Native()))

	C.gnome_bg_crossfade_stop(_arg0)
	runtime.KeepAlive(fade)
}

// The function takes the following parameters:
//
func (fade *BGCrossfade) finished(window gdk.Windower) {
	gclass := (*C.GnomeBGCrossfadeClass)(coreglib.PeekParentClass(fade))
	fnarg := gclass.finished

	var _arg0 *C.GnomeBGCrossfade // out
	var _arg1 *C.GdkWindow        // out

	_arg0 = (*C.GnomeBGCrossfade)(unsafe.Pointer(coreglib.InternObject(fade).Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gnomedesktop3_BGCrossfade_virtual_finished(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(fade)
	runtime.KeepAlive(window)
}

// BGCrossfadeClass: instance of this type is always passed by reference.
type BGCrossfadeClass struct {
	*bgCrossfadeClass
}

// bgCrossfadeClass is the struct that's finalized.
type bgCrossfadeClass struct {
	native *C.GnomeBGCrossfadeClass
}
