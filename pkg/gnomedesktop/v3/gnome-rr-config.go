// Code generated by girgen. DO NOT EDIT.

package gnomedesktop

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeRRConfig     = coreglib.Type(C.gnome_rr_config_get_type())
	GTypeRROutputInfo = coreglib.Type(C.gnome_rr_output_info_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRRConfig, F: marshalRRConfig},
		coreglib.TypeMarshaler{T: GTypeRROutputInfo, F: marshalRROutputInfo},
	})
}

// RRConfigOverrides contains methods that are overridable.
type RRConfigOverrides struct {
}

func defaultRRConfigOverrides(v *RRConfig) RRConfigOverrides {
	return RRConfigOverrides{}
}

type RRConfig struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*RRConfig)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*RRConfig, *RRConfigClass, RRConfigOverrides](
		GTypeRRConfig,
		initRRConfigClass,
		wrapRRConfig,
		defaultRRConfigOverrides,
	)
}

func initRRConfigClass(gclass unsafe.Pointer, overrides RRConfigOverrides, classInitFunc func(*RRConfigClass)) {
	if classInitFunc != nil {
		class := (*RRConfigClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRRConfig(obj *coreglib.Object) *RRConfig {
	return &RRConfig{
		Object: obj,
	}
}

func marshalRRConfig(p uintptr) (interface{}, error) {
	return wrapRRConfig(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func NewRRConfigCurrent(screen *RRScreen) (*RRConfig, error) {
	var _arg1 *C.GnomeRRScreen // out
	var _cret *C.GnomeRRConfig // in
	var _cerr *C.GError        // in

	_arg1 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	_cret = C.gnome_rr_config_new_current(_arg1, &_cerr)
	runtime.KeepAlive(screen)

	var _rrConfig *RRConfig // out
	var _goerr error        // out

	_rrConfig = wrapRRConfig(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _rrConfig, _goerr
}

// The function takes the following parameters:
//
func (configuration *RRConfig) Applicable(screen *RRScreen) error {
	var _arg0 *C.GnomeRRConfig // out
	var _arg1 *C.GnomeRRScreen // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(configuration).Native()))
	_arg1 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	C.gnome_rr_config_applicable(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(configuration)
	runtime.KeepAlive(screen)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// The function takes the following parameters:
//
func (configuration *RRConfig) Apply(screen *RRScreen) error {
	var _arg0 *C.GnomeRRConfig // out
	var _arg1 *C.GnomeRRScreen // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(configuration).Native()))
	_arg1 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	C.gnome_rr_config_apply(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(configuration)
	runtime.KeepAlive(screen)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// The function takes the following parameters:
//
func (configuration *RRConfig) ApplyPersistent(screen *RRScreen) error {
	var _arg0 *C.GnomeRRConfig // out
	var _arg1 *C.GnomeRRScreen // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(configuration).Native()))
	_arg1 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	C.gnome_rr_config_apply_persistent(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(configuration)
	runtime.KeepAlive(screen)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// The function returns the following values:
//
func (configuration *RRConfig) EnsurePrimary() bool {
	var _arg0 *C.GnomeRRConfig // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(configuration).Native()))

	_cret = C.gnome_rr_config_ensure_primary(_arg0)
	runtime.KeepAlive(configuration)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (config1 *RRConfig) Equal(config2 *RRConfig) bool {
	var _arg0 *C.GnomeRRConfig // out
	var _arg1 *C.GnomeRRConfig // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(config1).Native()))
	_arg1 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(config2).Native()))

	_cret = C.gnome_rr_config_equal(_arg0, _arg1)
	runtime.KeepAlive(config1)
	runtime.KeepAlive(config2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - ok: whether at least two outputs are at (0, 0) offset and they have the
//     same width/height. Those outputs are of course connected and on (i.e.
//     they have a CRTC assigned).
//
func (configuration *RRConfig) Clone() bool {
	var _arg0 *C.GnomeRRConfig // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(configuration).Native()))

	_cret = C.gnome_rr_config_get_clone(_arg0)
	runtime.KeepAlive(configuration)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - rrOutputInfos: output configuration for this RRConfig.
//
func (configuration *RRConfig) Outputs() []*RROutputInfo {
	var _arg0 *C.GnomeRRConfig      // out
	var _cret **C.GnomeRROutputInfo // in

	_arg0 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(configuration).Native()))

	_cret = C.gnome_rr_config_get_outputs(_arg0)
	runtime.KeepAlive(configuration)

	var _rrOutputInfos []*RROutputInfo // out

	{
		var i int
		var z *C.GnomeRROutputInfo
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_rrOutputInfos = make([]*RROutputInfo, i)
		for i := range src {
			_rrOutputInfos[i] = wrapRROutputInfo(coreglib.Take(unsafe.Pointer(src[i])))
		}
	}

	return _rrOutputInfos
}

func (self *RRConfig) LoadCurrent() error {
	var _arg0 *C.GnomeRRConfig // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gnome_rr_config_load_current(_arg0, &_cerr)
	runtime.KeepAlive(self)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (config1 *RRConfig) Match(config2 *RRConfig) bool {
	var _arg0 *C.GnomeRRConfig // out
	var _arg1 *C.GnomeRRConfig // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(config1).Native()))
	_arg1 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(config2).Native()))

	_cret = C.gnome_rr_config_match(_arg0, _arg1)
	runtime.KeepAlive(config1)
	runtime.KeepAlive(config2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (configuration *RRConfig) Sanitize() {
	var _arg0 *C.GnomeRRConfig // out

	_arg0 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(configuration).Native()))

	C.gnome_rr_config_sanitize(_arg0)
	runtime.KeepAlive(configuration)
}

// The function takes the following parameters:
//
func (configuration *RRConfig) SetClone(clone bool) {
	var _arg0 *C.GnomeRRConfig // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GnomeRRConfig)(unsafe.Pointer(coreglib.InternObject(configuration).Native()))
	if clone {
		_arg1 = C.TRUE
	}

	C.gnome_rr_config_set_clone(_arg0, _arg1)
	runtime.KeepAlive(configuration)
	runtime.KeepAlive(clone)
}

// RROutputInfoOverrides contains methods that are overridable.
type RROutputInfoOverrides struct {
}

func defaultRROutputInfoOverrides(v *RROutputInfo) RROutputInfoOverrides {
	return RROutputInfoOverrides{}
}

type RROutputInfo struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*RROutputInfo)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*RROutputInfo, *RROutputInfoClass, RROutputInfoOverrides](
		GTypeRROutputInfo,
		initRROutputInfoClass,
		wrapRROutputInfo,
		defaultRROutputInfoOverrides,
	)
}

func initRROutputInfoClass(gclass unsafe.Pointer, overrides RROutputInfoOverrides, classInitFunc func(*RROutputInfoClass)) {
	if classInitFunc != nil {
		class := (*RROutputInfoClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRROutputInfo(obj *coreglib.Object) *RROutputInfo {
	return &RROutputInfo{
		Object: obj,
	}
}

func marshalRROutputInfo(p uintptr) (interface{}, error) {
	return wrapRROutputInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
func (self *RROutputInfo) AspectRatio() float64 {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret C.double             // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_get_aspect_ratio(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// The function returns the following values:
//
//   - utf8: display name of this output.
//
func (self *RROutputInfo) DisplayName() string {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret *C.char              // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_get_display_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Geometry: get the geometry for the monitor connected to the specified output.
// If the monitor is a tiled monitor, it returns the geometry for the complete
// monitor.
//
// The function returns the following values:
//
//   - x (optional)
//   - y (optional)
//   - width (optional)
//   - height (optional)
//
func (self *RROutputInfo) Geometry() (x, y, width, height int) {
	var _arg0 *C.GnomeRROutputInfo // out
	var _arg1 C.int                // in
	var _arg2 C.int                // in
	var _arg3 C.int                // in
	var _arg4 C.int                // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gnome_rr_output_info_get_geometry(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(self)

	var _x int      // out
	var _y int      // out
	var _width int  // out
	var _height int // out

	_x = int(_arg1)
	_y = int(_arg2)
	_width = int(_arg3)
	_height = int(_arg4)

	return _x, _y, _width, _height
}

// The function returns the following values:
//
//   - utf8: output name.
//
func (self *RROutputInfo) Name() string {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret *C.char              // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_get_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
func (self *RROutputInfo) PreferredHeight() int {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret C.int                // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_get_preferred_height(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
func (self *RROutputInfo) PreferredWidth() int {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret C.int                // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_get_preferred_width(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
func (self *RROutputInfo) Primary() bool {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_get_primary(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (self *RROutputInfo) Product() string {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret *C.char              // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_get_product(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
func (self *RROutputInfo) RefreshRate() int {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret C.int                // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_get_refresh_rate(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
func (self *RROutputInfo) Rotation() RRRotation {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret C.GnomeRRRotation    // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_get_rotation(_arg0)
	runtime.KeepAlive(self)

	var _rrRotation RRRotation // out

	_rrRotation = RRRotation(_cret)

	return _rrRotation
}

// The function returns the following values:
//
func (self *RROutputInfo) Serial() string {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret *C.char              // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_get_serial(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
func (self *RROutputInfo) Underscanning() bool {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_get_underscanning(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (self *RROutputInfo) Vendor() string {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret *C.char              // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_get_vendor(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//   - ok: whether there is a CRTC assigned to this output (i.e. a signal is
//     being sent to it).
//
func (self *RROutputInfo) IsActive() bool {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_is_active(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - ok: whether the output is physically connected to a monitor.
//
func (self *RROutputInfo) IsConnected() bool {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_is_connected(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - ok: TRUE if the specified output is connected to the primary tile of a
//     monitor or to an untiled monitor, FALSE if the output is connected to a
//     secondary tile.
//
func (self *RROutputInfo) IsPrimaryTile() bool {
	var _arg0 *C.GnomeRROutputInfo // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gnome_rr_output_info_is_primary_tile(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (self *RROutputInfo) SetActive(active bool) {
	var _arg0 *C.GnomeRROutputInfo // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if active {
		_arg1 = C.TRUE
	}

	C.gnome_rr_output_info_set_active(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(active)
}

// SetGeometry: set the geometry for the monitor connected to the specified
// output. If the monitor is a tiled monitor, it sets the geometry for the
// complete monitor.
//
// The function takes the following parameters:
//
//   - x offset for monitor.
//   - y offset for monitor.
//   - width: monitor width.
//   - height: monitor height.
//
func (self *RROutputInfo) SetGeometry(x, y, width, height int) {
	var _arg0 *C.GnomeRROutputInfo // out
	var _arg1 C.int                // out
	var _arg2 C.int                // out
	var _arg3 C.int                // out
	var _arg4 C.int                // out

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)
	_arg3 = C.int(width)
	_arg4 = C.int(height)

	C.gnome_rr_output_info_set_geometry(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// The function takes the following parameters:
//
func (self *RROutputInfo) SetPrimary(primary bool) {
	var _arg0 *C.GnomeRROutputInfo // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if primary {
		_arg1 = C.TRUE
	}

	C.gnome_rr_output_info_set_primary(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(primary)
}

// The function takes the following parameters:
//
func (self *RROutputInfo) SetRefreshRate(rate int) {
	var _arg0 *C.GnomeRROutputInfo // out
	var _arg1 C.int                // out

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(rate)

	C.gnome_rr_output_info_set_refresh_rate(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(rate)
}

// The function takes the following parameters:
//
func (self *RROutputInfo) SetRotation(rotation RRRotation) {
	var _arg0 *C.GnomeRROutputInfo // out
	var _arg1 C.GnomeRRRotation    // out

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GnomeRRRotation(rotation)

	C.gnome_rr_output_info_set_rotation(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(rotation)
}

// The function takes the following parameters:
//
func (self *RROutputInfo) SetUnderscanning(underscanning bool) {
	var _arg0 *C.GnomeRROutputInfo // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if underscanning {
		_arg1 = C.TRUE
	}

	C.gnome_rr_output_info_set_underscanning(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(underscanning)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (self *RROutputInfo) SupportsRotation(rotation RRRotation) bool {
	var _arg0 *C.GnomeRROutputInfo // out
	var _arg1 C.GnomeRRRotation    // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GnomeRROutputInfo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GnomeRRRotation(rotation)

	_cret = C.gnome_rr_output_info_supports_rotation(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(rotation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RRConfigClass: instance of this type is always passed by reference.
type RRConfigClass struct {
	*rrConfigClass
}

// rrConfigClass is the struct that's finalized.
type rrConfigClass struct {
	native *C.GnomeRRConfigClass
}

// RROutputInfoClass: instance of this type is always passed by reference.
type RROutputInfoClass struct {
	*rrOutputInfoClass
}

// rrOutputInfoClass is the struct that's finalized.
type rrOutputInfoClass struct {
	native *C.GnomeRROutputInfoClass
}
