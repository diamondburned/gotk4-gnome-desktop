// Code generated by girgen. DO NOT EDIT.

package gnomedesktop

import (
	"runtime"
	"unsafe"
)

// #include <stdlib.h>
import "C"

// GetAllLocales gets all locales.
//
// The function returns the following values:
//
//   - utf8s: a newly allocated NULL-terminated string array containing the all
//     locales. Free with g_strfreev().
//
func GetAllLocales() []string {
	var _cret **C.char // in

	_cret = C.gnome_get_all_locales()

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// GetCountryFromCode gets the country name for code. If translation is provided
// the returned string is translated accordingly.
//
// The function takes the following parameters:
//
//   - code: ISO 3166 code string.
//   - translation (optional): locale string.
//
// The function returns the following values:
//
//   - utf8: country name. Caller takes ownership.
//
func GetCountryFromCode(code, translation string) string {
	var _arg1 *C.char // out
	var _arg2 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg1))
	if translation != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(translation)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gnome_get_country_from_code(_arg1, _arg2)
	runtime.KeepAlive(code)
	runtime.KeepAlive(translation)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GetCountryFromLocale gets the country description for locale. If translation
// is provided the returned string is translated accordingly.
//
// The function takes the following parameters:
//
//   - locale string.
//   - translation (optional): locale string.
//
// The function returns the following values:
//
//   - utf8: country description. Caller takes ownership.
//
func GetCountryFromLocale(locale, translation string) string {
	var _arg1 *C.char // out
	var _arg2 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(_arg1))
	if translation != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(translation)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gnome_get_country_from_locale(_arg1, _arg2)
	runtime.KeepAlive(locale)
	runtime.KeepAlive(translation)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GetInputSourceFromLocale gets the default input source's type and identifier
// for a given locale.
//
// The function takes the following parameters:
//
//   - locale string.
//
// The function returns the following values:
//
//   - typ: location to store the input source type.
//   - id: location to store the input source identifier.
//   - ok: TRUE if a input source exists or FALSE otherwise.
//
func GetInputSourceFromLocale(locale string) (typ, id string, ok bool) {
	var _arg1 *C.char    // out
	var _arg2 *C.char    // in
	var _arg3 *C.char    // in
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gnome_get_input_source_from_locale(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(locale)

	var _typ string // out
	var _id string  // out
	var _ok bool    // out

	_typ = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	_id = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	if _cret != 0 {
		_ok = true
	}

	return _typ, _id, _ok
}

// GetLanguageFromCode gets the language name for code. If translation is
// provided the returned string is translated accordingly.
//
// The function takes the following parameters:
//
//   - code: ISO 639 code string.
//   - translation (optional): locale string.
//
// The function returns the following values:
//
//   - utf8: language name. Caller takes ownership.
//
func GetLanguageFromCode(code, translation string) string {
	var _arg1 *C.char // out
	var _arg2 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg1))
	if translation != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(translation)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gnome_get_language_from_code(_arg1, _arg2)
	runtime.KeepAlive(code)
	runtime.KeepAlive(translation)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GetLanguageFromLocale gets the language description for locale. If
// translation is provided the returned string is translated accordingly.
//
// The function takes the following parameters:
//
//   - locale string.
//   - translation (optional): locale string.
//
// The function returns the following values:
//
//   - utf8: language description. Caller takes ownership.
//
func GetLanguageFromLocale(locale, translation string) string {
	var _arg1 *C.char // out
	var _arg2 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(_arg1))
	if translation != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(translation)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gnome_get_language_from_locale(_arg1, _arg2)
	runtime.KeepAlive(locale)
	runtime.KeepAlive(translation)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// LanguageHasTranslations returns TRUE if there are translations for language
// code.
//
// The function takes the following parameters:
//
//   - code: ISO 639 code string.
//
// The function returns the following values:
//
//   - ok: TRUE if there are translations for language code.
//
func LanguageHasTranslations(code string) bool {
	var _arg1 *C.char    // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gnome_language_has_translations(_arg1)
	runtime.KeepAlive(code)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NormalizeLocale gets the normalized locale string in the form
// [language[_country][.codeset][modifier]] for name.
//
// The function takes the following parameters:
//
//   - locale string.
//
// The function returns the following values:
//
//   - utf8: normalized locale string. Caller takes ownership.
//
func NormalizeLocale(locale string) string {
	var _arg1 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gnome_normalize_locale(_arg1)
	runtime.KeepAlive(locale)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ParseLocale extracts the various components of a locale string
// in XPG format. ([language[_country][.codeset][modifier]]). See
// http://en.wikipedia.org/wiki/Locale.
//
// The function takes the following parameters:
//
//   - locale string.
//
// The function returns the following values:
//
//   - languageCodep (optional): location to store the language code, or NULL.
//   - countryCodep (optional): location to store the country code, or NULL.
//   - codesetp (optional): location to store the codeset, or NULL.
//   - modifierp (optional): location to store the modifier, or NULL.
//   - ok: TRUE if parsing was successful.
//
func ParseLocale(locale string) (languageCodep, countryCodep, codesetp, modifierp string, ok bool) {
	var _arg1 *C.char    // out
	var _arg2 *C.char    // in
	var _arg3 *C.char    // in
	var _arg4 *C.char    // in
	var _arg5 *C.char    // in
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gnome_parse_locale(_arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(locale)

	var _languageCodep string // out
	var _countryCodep string  // out
	var _codesetp string      // out
	var _modifierp string     // out
	var _ok bool              // out

	if _arg2 != nil {
		_languageCodep = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _arg3 != nil {
		_countryCodep = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _arg4 != nil {
		_codesetp = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if _arg5 != nil {
		_modifierp = C.GoString((*C.gchar)(unsafe.Pointer(_arg5)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if _cret != 0 {
		_ok = true
	}

	return _languageCodep, _countryCodep, _codesetp, _modifierp, _ok
}
