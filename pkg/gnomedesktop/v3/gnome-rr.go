// Code generated by girgen. DO NOT EDIT.

package gnomedesktop

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// extern void _gotk4_gnomedesktop3_RRScreen_ConnectOutputDisconnected(gpointer, gpointer, guintptr);
// extern void _gotk4_gnomedesktop3_RRScreen_ConnectOutputConnected(gpointer, gpointer, guintptr);
// extern void _gotk4_gnomedesktop3_RRScreen_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gnomedesktop3_RRScreenClass_output_disconnected(GnomeRRScreen*, GnomeRROutput*);
// extern void _gotk4_gnomedesktop3_RRScreenClass_output_connected(GnomeRRScreen*, GnomeRROutput*);
// extern void _gotk4_gnomedesktop3_RRScreenClass_changed(GnomeRRScreen*);
// void _gotk4_gnomedesktop3_RRScreen_virtual_changed(void* fnptr, GnomeRRScreen* arg0) {
//   ((void (*)(GnomeRRScreen*))(fnptr))(arg0);
// };
// void _gotk4_gnomedesktop3_RRScreen_virtual_output_connected(void* fnptr, GnomeRRScreen* arg0, GnomeRROutput* arg1) {
//   ((void (*)(GnomeRRScreen*, GnomeRROutput*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gnomedesktop3_RRScreen_virtual_output_disconnected(void* fnptr, GnomeRRScreen* arg0, GnomeRROutput* arg1) {
//   ((void (*)(GnomeRRScreen*, GnomeRROutput*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeRRScreen = coreglib.Type(C.gnome_rr_screen_get_type())
	GTypeRRCrtc   = coreglib.Type(C.gnome_rr_crtc_get_type())
	GTypeRRMode   = coreglib.Type(C.gnome_rr_mode_get_type())
	GTypeRROutput = coreglib.Type(C.gnome_rr_output_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRRScreen, F: marshalRRScreen},
		coreglib.TypeMarshaler{T: GTypeRRCrtc, F: marshalRRCrtc},
		coreglib.TypeMarshaler{T: GTypeRRMode, F: marshalRRMode},
		coreglib.TypeMarshaler{T: GTypeRROutput, F: marshalRROutput},
	})
}

const RR_CONNECTOR_TYPE_PANEL = "Panel"

type RRDpmsMode C.gint

const (
	RrDpmsOn RRDpmsMode = iota
	RrDpmsStandby
	RrDpmsSuspend
	RrDpmsOff
	RrDpmsUnknown
)

// String returns the name in string for RRDpmsMode.
func (r RRDpmsMode) String() string {
	switch r {
	case RrDpmsOn:
		return "On"
	case RrDpmsStandby:
		return "Standby"
	case RrDpmsSuspend:
		return "Suspend"
	case RrDpmsOff:
		return "Off"
	case RrDpmsUnknown:
		return "Unknown"
	default:
		return fmt.Sprintf("RRDpmsMode(%d)", r)
	}
}

type RRError C.gint

const (
	RrErrorUnknown RRError = iota
	RrErrorNoRandrExtension
	RrErrorRandrError
	RrErrorBoundsError
	RrErrorCrtcAssignment
	RrErrorNoMatchingConfig
	RrErrorNoDpmsExtension
)

// String returns the name in string for RRError.
func (r RRError) String() string {
	switch r {
	case RrErrorUnknown:
		return "Unknown"
	case RrErrorNoRandrExtension:
		return "NoRandrExtension"
	case RrErrorRandrError:
		return "RandrError"
	case RrErrorBoundsError:
		return "BoundsError"
	case RrErrorCrtcAssignment:
		return "CrtcAssignment"
	case RrErrorNoMatchingConfig:
		return "NoMatchingConfig"
	case RrErrorNoDpmsExtension:
		return "NoDpmsExtension"
	default:
		return fmt.Sprintf("RRError(%d)", r)
	}
}

type RRRotation C.guint

const (
	RrRotationNext RRRotation = 0b0
	RrRotation0    RRRotation = 0b1
	RrRotation90   RRRotation = 0b10
	RrRotation180  RRRotation = 0b100
	RrRotation270  RRRotation = 0b1000
	RrReflectX     RRRotation = 0b10000
	RrReflectY     RRRotation = 0b100000
)

// String returns the names in string for RRRotation.
func (r RRRotation) String() string {
	if r == 0 {
		return "RRRotation(0)"
	}

	var builder strings.Builder
	builder.Grow(89)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RrRotationNext:
			builder.WriteString("RotationNext|")
		case RrRotation0:
			builder.WriteString("Rotation0|")
		case RrRotation90:
			builder.WriteString("Rotation90|")
		case RrRotation180:
			builder.WriteString("Rotation180|")
		case RrRotation270:
			builder.WriteString("Rotation270|")
		case RrReflectX:
			builder.WriteString("ReflectX|")
		case RrReflectY:
			builder.WriteString("ReflectY|")
		default:
			builder.WriteString(fmt.Sprintf("RRRotation(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RRRotation) Has(other RRRotation) bool {
	return (r & other) == other
}

// RrErrorQuark returns the #GQuark that will be used for #GError values
// returned by the GnomeRR API.
//
// The function returns the following values:
//
//   - quark used to identify errors coming from the GnomeRR API.
//
func RrErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gnome_rr_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// RRScreenOverrides contains methods that are overridable.
type RRScreenOverrides struct {
	Changed func()
	// The function takes the following parameters:
	//
	OutputConnected func(output *RROutput)
	// The function takes the following parameters:
	//
	OutputDisconnected func(output *RROutput)
}

func defaultRRScreenOverrides(v *RRScreen) RRScreenOverrides {
	return RRScreenOverrides{
		Changed:            v.changed,
		OutputConnected:    v.outputConnected,
		OutputDisconnected: v.outputDisconnected,
	}
}

type RRScreen struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.AsyncInitable
	gio.Initable
}

var (
	_ coreglib.Objector = (*RRScreen)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*RRScreen, *RRScreenClass, RRScreenOverrides](
		GTypeRRScreen,
		initRRScreenClass,
		wrapRRScreen,
		defaultRRScreenOverrides,
	)
}

func initRRScreenClass(gclass unsafe.Pointer, overrides RRScreenOverrides, classInitFunc func(*RRScreenClass)) {
	pclass := (*C.GnomeRRScreenClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeRRScreen))))

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_gnomedesktop3_RRScreenClass_changed)
	}

	if overrides.OutputConnected != nil {
		pclass.output_connected = (*[0]byte)(C._gotk4_gnomedesktop3_RRScreenClass_output_connected)
	}

	if overrides.OutputDisconnected != nil {
		pclass.output_disconnected = (*[0]byte)(C._gotk4_gnomedesktop3_RRScreenClass_output_disconnected)
	}

	if classInitFunc != nil {
		class := (*RRScreenClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRRScreen(obj *coreglib.Object) *RRScreen {
	return &RRScreen{
		Object: obj,
		AsyncInitable: gio.AsyncInitable{
			Object: obj,
		},
		Initable: gio.Initable{
			Object: obj,
		},
	}
}

func marshalRRScreen(p uintptr) (interface{}, error) {
	return wrapRRScreen(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (screen *RRScreen) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(screen, "changed", false, unsafe.Pointer(C._gotk4_gnomedesktop3_RRScreen_ConnectChanged), f)
}

// ConnectOutputConnected: this signal is emitted when a display device is
// connected to a port, or a port is hotplugged with an active output. The
// latter can happen if a laptop is docked, and the dock provides a new active
// output.
//
// The output value is not a #GObject. The returned output value can only
// assume to be valid during the emission of the signal (i.e. within your signal
// handler only), as it may change later when the screen is modified due to an
// event from the X server, or due to another place in the application modifying
// the screen and the output. Therefore, deal with changes to the output right
// in your signal handler, instead of keeping the output reference for an async
// or idle function.
func (screen *RRScreen) ConnectOutputConnected(f func(output unsafe.Pointer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(screen, "output-connected", false, unsafe.Pointer(C._gotk4_gnomedesktop3_RRScreen_ConnectOutputConnected), f)
}

// ConnectOutputDisconnected: this signal is emitted when a display device is
// disconnected from a port, or a port output is hot-unplugged. The latter can
// happen if a laptop is undocked, and the dock provided the output.
//
// The output value is not a #GObject. The returned output value can only
// assume to be valid during the emission of the signal (i.e. within your signal
// handler only), as it may change later when the screen is modified due to an
// event from the X server, or due to another place in the application modifying
// the screen and the output. Therefore, deal with changes to the output right
// in your signal handler, instead of keeping the output reference for an async
// or idle function.
func (screen *RRScreen) ConnectOutputDisconnected(f func(output unsafe.Pointer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(screen, "output-disconnected", false, unsafe.Pointer(C._gotk4_gnomedesktop3_RRScreen_ConnectOutputDisconnected), f)
}

// NewRRScreen creates a unique RRScreen instance for the specified screen.
//
// The function takes the following parameters:
//
//   - screen on which to operate.
//
// The function returns the following values:
//
//   - rrScreen: unique RRScreen instance, specific to the screen, or NULL if
//     this could not be created, for instance if the driver does not support
//     Xrandr 1.2. Each Screen thus has a single instance of RRScreen.
//
func NewRRScreen(screen *gdk.Screen) (*RRScreen, error) {
	var _arg1 *C.GdkScreen     // out
	var _cret *C.GnomeRRScreen // in
	var _cerr *C.GError        // in

	_arg1 = (*C.GdkScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	_cret = C.gnome_rr_screen_new(_arg1, &_cerr)
	runtime.KeepAlive(screen)

	var _rrScreen *RRScreen // out
	var _goerr error        // out

	_rrScreen = wrapRRScreen(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _rrScreen, _goerr
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func NewRRScreenFinish(result gio.AsyncResulter) (*RRScreen, error) {
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GnomeRRScreen // in
	var _cerr *C.GError        // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.gnome_rr_screen_new_finish(_arg1, &_cerr)
	runtime.KeepAlive(result)

	var _rrScreen *RRScreen // out
	var _goerr error        // out

	_rrScreen = wrapRRScreen(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _rrScreen, _goerr
}

// The function takes the following parameters:
//
// The function returns the following values:
//
//   - rrCrtc: CRTC identified by id.
//
func (screen *RRScreen) CrtcByID(id uint32) *RRCrtc {
	var _arg0 *C.GnomeRRScreen // out
	var _arg1 C.guint32        // out
	var _cret *C.GnomeRRCrtc   // in

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	_arg1 = C.guint32(id)

	_cret = C.gnome_rr_screen_get_crtc_by_id(_arg0, _arg1)
	runtime.KeepAlive(screen)
	runtime.KeepAlive(id)

	var _rrCrtc *RRCrtc // out

	_rrCrtc = (*RRCrtc)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rrCrtc
}

// The function returns the following values:
//
//   - mode: current RRDpmsMode of this screen.
//
func (screen *RRScreen) DpmsMode() (RRDpmsMode, error) {
	var _arg0 *C.GnomeRRScreen  // out
	var _arg1 C.GnomeRRDpmsMode // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	C.gnome_rr_screen_get_dpms_mode(_arg0, &_arg1, &_cerr)
	runtime.KeepAlive(screen)

	var _mode RRDpmsMode // out
	var _goerr error     // out

	_mode = RRDpmsMode(_arg1)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _mode, _goerr
}

// The function takes the following parameters:
//
// The function returns the following values:
//
//   - rrOutput: output identified by id.
//
func (screen *RRScreen) OutputByID(id uint32) *RROutput {
	var _arg0 *C.GnomeRRScreen // out
	var _arg1 C.guint32        // out
	var _cret *C.GnomeRROutput // in

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	_arg1 = C.guint32(id)

	_cret = C.gnome_rr_screen_get_output_by_id(_arg0, _arg1)
	runtime.KeepAlive(screen)
	runtime.KeepAlive(id)

	var _rrOutput *RROutput // out

	_rrOutput = (*RROutput)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rrOutput
}

// The function takes the following parameters:
//
// The function returns the following values:
//
//   - rrOutput: output identified by name.
//
func (screen *RRScreen) OutputByName(name string) *RROutput {
	var _arg0 *C.GnomeRRScreen // out
	var _arg1 *C.char          // out
	var _cret *C.GnomeRROutput // in

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gnome_rr_screen_get_output_by_name(_arg0, _arg1)
	runtime.KeepAlive(screen)
	runtime.KeepAlive(name)

	var _rrOutput *RROutput // out

	_rrOutput = (*RROutput)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rrOutput
}

// Ranges: get the ranges of the screen.
//
// The function returns the following values:
//
//   - minWidth: minimum width.
//   - maxWidth: maximum width.
//   - minHeight: minimum height.
//   - maxHeight: maximum height.
//
func (screen *RRScreen) Ranges() (minWidth, maxWidth, minHeight, maxHeight int) {
	var _arg0 *C.GnomeRRScreen // out
	var _arg1 C.int            // in
	var _arg2 C.int            // in
	var _arg3 C.int            // in
	var _arg4 C.int            // in

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	C.gnome_rr_screen_get_ranges(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(screen)

	var _minWidth int  // out
	var _maxWidth int  // out
	var _minHeight int // out
	var _maxHeight int // out

	_minWidth = int(_arg1)
	_maxWidth = int(_arg2)
	_minHeight = int(_arg3)
	_maxHeight = int(_arg4)

	return _minWidth, _maxWidth, _minHeight, _maxHeight
}

// ListCloneModes: list available XRandR clone modes.
//
// The function returns the following values:
//
func (screen *RRScreen) ListCloneModes() []*RRMode {
	var _arg0 *C.GnomeRRScreen // out
	var _cret **C.GnomeRRMode  // in

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	_cret = C.gnome_rr_screen_list_clone_modes(_arg0)
	runtime.KeepAlive(screen)

	var _rrModes []*RRMode // out

	{
		var i int
		var z *C.GnomeRRMode
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_rrModes = make([]*RRMode, i)
		for i := range src {
			_rrModes[i] = (*RRMode)(gextras.NewStructNative(unsafe.Pointer(src[i])))
		}
	}

	return _rrModes
}

// ListCrtcs: list all CRTCs.
//
// The function returns the following values:
//
func (screen *RRScreen) ListCrtcs() []*RRCrtc {
	var _arg0 *C.GnomeRRScreen // out
	var _cret **C.GnomeRRCrtc  // in

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	_cret = C.gnome_rr_screen_list_crtcs(_arg0)
	runtime.KeepAlive(screen)

	var _rrCrtcs []*RRCrtc // out

	{
		var i int
		var z *C.GnomeRRCrtc
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_rrCrtcs = make([]*RRCrtc, i)
		for i := range src {
			_rrCrtcs[i] = (*RRCrtc)(gextras.NewStructNative(unsafe.Pointer(src[i])))
		}
	}

	return _rrCrtcs
}

// ListModes: list available XRandR modes.
//
// The function returns the following values:
//
func (screen *RRScreen) ListModes() []*RRMode {
	var _arg0 *C.GnomeRRScreen // out
	var _cret **C.GnomeRRMode  // in

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	_cret = C.gnome_rr_screen_list_modes(_arg0)
	runtime.KeepAlive(screen)

	var _rrModes []*RRMode // out

	{
		var i int
		var z *C.GnomeRRMode
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_rrModes = make([]*RRMode, i)
		for i := range src {
			_rrModes[i] = (*RRMode)(gextras.NewStructNative(unsafe.Pointer(src[i])))
		}
	}

	return _rrModes
}

// ListOutputs: list all outputs.
//
// The function returns the following values:
//
func (screen *RRScreen) ListOutputs() []*RROutput {
	var _arg0 *C.GnomeRRScreen  // out
	var _cret **C.GnomeRROutput // in

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	_cret = C.gnome_rr_screen_list_outputs(_arg0)
	runtime.KeepAlive(screen)

	var _rrOutputs []*RROutput // out

	{
		var i int
		var z *C.GnomeRROutput
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_rrOutputs = make([]*RROutput, i)
		for i := range src {
			_rrOutputs[i] = (*RROutput)(gextras.NewStructNative(unsafe.Pointer(src[i])))
		}
	}

	return _rrOutputs
}

// Refresh refreshes the screen configuration, and calls the screen's callback
// if it exists and if the screen's configuration changed.
func (screen *RRScreen) Refresh() error {
	var _arg0 *C.GnomeRRScreen // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	C.gnome_rr_screen_refresh(_arg0, &_cerr)
	runtime.KeepAlive(screen)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetDpmsMode: this method also disables the DPMS timeouts.
//
// The function takes the following parameters:
//
func (screen *RRScreen) SetDpmsMode(mode RRDpmsMode) error {
	var _arg0 *C.GnomeRRScreen  // out
	var _arg1 C.GnomeRRDpmsMode // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	_arg1 = C.GnomeRRDpmsMode(mode)

	C.gnome_rr_screen_set_dpms_mode(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(screen)
	runtime.KeepAlive(mode)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func (screen *RRScreen) changed() {
	gclass := (*C.GnomeRRScreenClass)(coreglib.PeekParentClass(screen))
	fnarg := gclass.changed

	var _arg0 *C.GnomeRRScreen // out

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	C._gotk4_gnomedesktop3_RRScreen_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(screen)
}

// The function takes the following parameters:
//
func (screen *RRScreen) outputConnected(output *RROutput) {
	gclass := (*C.GnomeRRScreenClass)(coreglib.PeekParentClass(screen))
	fnarg := gclass.output_connected

	var _arg0 *C.GnomeRRScreen // out
	var _arg1 *C.GnomeRROutput // out

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	_arg1 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	C._gotk4_gnomedesktop3_RRScreen_virtual_output_connected(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(screen)
	runtime.KeepAlive(output)
}

// The function takes the following parameters:
//
func (screen *RRScreen) outputDisconnected(output *RROutput) {
	gclass := (*C.GnomeRRScreenClass)(coreglib.PeekParentClass(screen))
	fnarg := gclass.output_disconnected

	var _arg0 *C.GnomeRRScreen // out
	var _arg1 *C.GnomeRROutput // out

	_arg0 = (*C.GnomeRRScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	_arg1 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	C._gotk4_gnomedesktop3_RRScreen_virtual_output_disconnected(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(screen)
	runtime.KeepAlive(output)
}

// RRCTM: instance of this type is always passed by reference.
type RRCTM struct {
	*rrctM
}

// rrctM is the struct that's finalized.
type rrctM struct {
	native *C.GnomeRRCTM
}

func (r *RRCTM) Matrix() [9]uint64 {
	valptr := &r.native.matrix
	var _v [9]uint64 // out
	_v = *(*[9]uint64)(unsafe.Pointer(&*valptr))
	return _v
}

// RRCrtc: instance of this type is always passed by reference.
type RRCrtc struct {
	*rrCrtc
}

// rrCrtc is the struct that's finalized.
type rrCrtc struct {
	native *C.GnomeRRCrtc
}

func marshalRRCrtc(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &RRCrtc{&rrCrtc{(*C.GnomeRRCrtc)(b)}}, nil
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (crtc *RRCrtc) CanDriveOutput(output *RROutput) bool {
	var _arg0 *C.GnomeRRCrtc   // out
	var _arg1 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))
	_arg1 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_crtc_can_drive_output(_arg0, _arg1)
	runtime.KeepAlive(crtc)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - rrMode: current mode of this crtc.
//
func (crtc *RRCrtc) CurrentMode() *RRMode {
	var _arg0 *C.GnomeRRCrtc // out
	var _cret *C.GnomeRRMode // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))

	_cret = C.gnome_rr_crtc_get_current_mode(_arg0)
	runtime.KeepAlive(crtc)

	var _rrMode *RRMode // out

	_rrMode = (*RRMode)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rrMode
}

// The function returns the following values:
//
func (crtc *RRCrtc) CurrentRotation() RRRotation {
	var _arg0 *C.GnomeRRCrtc    // out
	var _cret C.GnomeRRRotation // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))

	_cret = C.gnome_rr_crtc_get_current_rotation(_arg0)
	runtime.KeepAlive(crtc)

	var _rrRotation RRRotation // out

	_rrRotation = RRRotation(_cret)

	return _rrRotation
}

// The function takes the following parameters:
//
// The function returns the following values:
//
//   - red: minimum width.
//   - green: maximum width.
//   - blue: minimum height.
//   - ok: TRUE for success.
//
func (crtc *RRCrtc) Gamma(size *int) (red *uint16, green *uint16, blue *uint16, ok bool) {
	var _arg0 *C.GnomeRRCrtc // out
	var _arg1 *C.int         // out
	var _arg2 *C.ushort      // in
	var _arg3 *C.ushort      // in
	var _arg4 *C.ushort      // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))
	_arg1 = (*C.int)(unsafe.Pointer(size))

	_cret = C.gnome_rr_crtc_get_gamma(_arg0, _arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(crtc)
	runtime.KeepAlive(size)

	var _red *uint16   // out
	var _green *uint16 // out
	var _blue *uint16  // out
	var _ok bool       // out

	_red = (*uint16)(unsafe.Pointer(_arg2))
	_green = (*uint16)(unsafe.Pointer(_arg3))
	_blue = (*uint16)(unsafe.Pointer(_arg4))
	if _cret != 0 {
		_ok = true
	}

	return _red, _green, _blue, _ok
}

// The function returns the following values:
//
func (crtc *RRCrtc) ID() uint32 {
	var _arg0 *C.GnomeRRCrtc // out
	var _cret C.guint32      // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))

	_cret = C.gnome_rr_crtc_get_id(_arg0)
	runtime.KeepAlive(crtc)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// The function returns the following values:
//
//   - x (optional)
//   - y (optional)
//
func (crtc *RRCrtc) Position() (x int, y int) {
	var _arg0 *C.GnomeRRCrtc // out
	var _arg1 C.int          // in
	var _arg2 C.int          // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))

	C.gnome_rr_crtc_get_position(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(crtc)

	var _x int // out
	var _y int // out

	_x = int(_arg1)
	_y = int(_arg2)

	return _x, _y
}

// The function returns the following values:
//
func (crtc *RRCrtc) Rotations() RRRotation {
	var _arg0 *C.GnomeRRCrtc    // out
	var _cret C.GnomeRRRotation // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))

	_cret = C.gnome_rr_crtc_get_rotations(_arg0)
	runtime.KeepAlive(crtc)

	var _rrRotation RRRotation // out

	_rrRotation = RRRotation(_cret)

	return _rrRotation
}

// The function takes the following parameters:
//
//   - size
//   - red
//   - green
//   - blue
//
// The function returns the following values:
//
func (crtc *RRCrtc) SetGamma(size int, red *uint16, green *uint16, blue *uint16) bool {
	var _arg0 *C.GnomeRRCrtc // out
	var _arg1 C.int          // out
	var _arg2 *C.ushort      // out
	var _arg3 *C.ushort      // out
	var _arg4 *C.ushort      // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))
	_arg1 = C.int(size)
	_arg2 = (*C.ushort)(unsafe.Pointer(red))
	_arg3 = (*C.ushort)(unsafe.Pointer(green))
	_arg4 = (*C.ushort)(unsafe.Pointer(blue))

	_cret = C.gnome_rr_crtc_set_gamma(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(crtc)
	runtime.KeepAlive(size)
	runtime.KeepAlive(red)
	runtime.KeepAlive(green)
	runtime.KeepAlive(blue)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (crtc *RRCrtc) SupportsRotation(rotation RRRotation) bool {
	var _arg0 *C.GnomeRRCrtc    // out
	var _arg1 C.GnomeRRRotation // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))
	_arg1 = C.GnomeRRRotation(rotation)

	_cret = C.gnome_rr_crtc_supports_rotation(_arg0, _arg1)
	runtime.KeepAlive(crtc)
	runtime.KeepAlive(rotation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RRMode: instance of this type is always passed by reference.
type RRMode struct {
	*rrMode
}

// rrMode is the struct that's finalized.
type rrMode struct {
	native *C.GnomeRRMode
}

func marshalRRMode(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &RRMode{&rrMode{(*C.GnomeRRMode)(b)}}, nil
}

// The function returns the following values:
//
func (mode *RRMode) Freq() int {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.int          // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_freq(_arg0)
	runtime.KeepAlive(mode)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
func (mode *RRMode) FreqF() float64 {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.double       // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_freq_f(_arg0)
	runtime.KeepAlive(mode)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// The function returns the following values:
//
func (mode *RRMode) Height() uint {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.guint        // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_height(_arg0)
	runtime.KeepAlive(mode)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
func (mode *RRMode) ID() uint32 {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.guint32      // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_id(_arg0)
	runtime.KeepAlive(mode)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// The function returns the following values:
//
func (mode *RRMode) IsInterlaced() bool {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_is_interlaced(_arg0)
	runtime.KeepAlive(mode)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsTiled returns TRUE if this mode is a tiled mode created for span a tiled
// monitor.
//
// The function returns the following values:
//
func (mode *RRMode) IsTiled() bool {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_is_tiled(_arg0)
	runtime.KeepAlive(mode)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (mode *RRMode) Width() uint {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.guint        // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_width(_arg0)
	runtime.KeepAlive(mode)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// RROutput: instance of this type is always passed by reference.
type RROutput struct {
	*rrOutput
}

// rrOutput is the struct that's finalized.
type rrOutput struct {
	native *C.GnomeRROutput
}

func marshalRROutput(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &RROutput{&rrOutput{(*C.GnomeRROutput)(b)}}, nil
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (output *RROutput) CanClone(clone *RROutput) bool {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))
	_arg1 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(clone)))

	_cret = C.gnome_rr_output_can_clone(_arg0, _arg1)
	runtime.KeepAlive(output)
	runtime.KeepAlive(clone)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - gint: currently set backlight brightness.
//
func (output *RROutput) Backlight() int {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gint           // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_backlight(_arg0)
	runtime.KeepAlive(output)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
func (output *RROutput) Crtc() *RRCrtc {
	var _arg0 *C.GnomeRROutput // out
	var _cret *C.GnomeRRCrtc   // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_crtc(_arg0)
	runtime.KeepAlive(output)

	var _rrCrtc *RRCrtc // out

	_rrCrtc = (*RRCrtc)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rrCrtc
}

// The function returns the following values:
//
//   - rrMode: current mode of this output.
//
func (output *RROutput) CurrentMode() *RRMode {
	var _arg0 *C.GnomeRROutput // out
	var _cret *C.GnomeRRMode   // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_current_mode(_arg0)
	runtime.KeepAlive(output)

	var _rrMode *RRMode // out

	_rrMode = (*RRMode)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rrMode
}

// The function returns the following values:
//
func (output *RROutput) DisplayName() string {
	var _arg0 *C.GnomeRROutput // out
	var _cret *C.char          // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_display_name(_arg0)
	runtime.KeepAlive(output)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (output *RROutput) EdidData(size *uint) *byte {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 *C.gsize         // out
	var _cret *C.guint8        // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))
	_arg1 = (*C.gsize)(unsafe.Pointer(size))

	_cret = C.gnome_rr_output_get_edid_data(_arg0, _arg1)
	runtime.KeepAlive(output)
	runtime.KeepAlive(size)

	var _guint8 *byte // out

	_guint8 = (*byte)(unsafe.Pointer(_cret))

	return _guint8
}

// The function returns the following values:
//
func (output *RROutput) ID() uint32 {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.guint32        // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_id(_arg0)
	runtime.KeepAlive(output)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// The function returns the following values:
//
//   - vendor (optional)
//   - product (optional)
//   - serial (optional)
//
func (output *RROutput) IDsFromEdid() (vendor string, product string, serial string) {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 *C.char          // in
	var _arg2 *C.char          // in
	var _arg3 *C.char          // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	C.gnome_rr_output_get_ids_from_edid(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(output)

	var _vendor string  // out
	var _product string // out
	var _serial string  // out

	if _arg1 != nil {
		_vendor = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if _arg2 != nil {
		_product = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _arg3 != nil {
		_serial = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	return _vendor, _product, _serial
}

// The function returns the following values:
//
func (output *RROutput) IsPrimary() bool {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_is_primary(_arg0)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (output *RROutput) IsUnderscanning() bool {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_is_underscanning(_arg0)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - gint: minimum backlight step available in percent.
//
func (output *RROutput) MinBacklightStep() int {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gint           // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_min_backlight_step(_arg0)
	runtime.KeepAlive(output)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
func (output *RROutput) Name() string {
	var _arg0 *C.GnomeRROutput // out
	var _cret *C.char          // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_name(_arg0)
	runtime.KeepAlive(output)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//   - widthMm (optional)
//   - heightMm (optional)
//
func (output *RROutput) PhysicalSize() (widthMm int, heightMm int) {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 C.int            // in
	var _arg2 C.int            // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	C.gnome_rr_output_get_physical_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(output)

	var _widthMm int  // out
	var _heightMm int // out

	_widthMm = int(_arg1)
	_heightMm = int(_arg2)

	return _widthMm, _heightMm
}

// The function returns the following values:
//
//   - x (optional)
//   - y (optional)
//
func (output *RROutput) Position() (x int, y int) {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 C.int            // in
	var _arg2 C.int            // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	C.gnome_rr_output_get_position(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(output)

	var _x int // out
	var _y int // out

	_x = int(_arg1)
	_y = int(_arg2)

	return _x, _y
}

// The function returns the following values:
//
func (output *RROutput) PossibleCrtcs() []*RRCrtc {
	var _arg0 *C.GnomeRROutput // out
	var _cret **C.GnomeRRCrtc  // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_possible_crtcs(_arg0)
	runtime.KeepAlive(output)

	var _rrCrtcs []*RRCrtc // out

	{
		var i int
		var z *C.GnomeRRCrtc
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_rrCrtcs = make([]*RRCrtc, i)
		for i := range src {
			_rrCrtcs[i] = (*RRCrtc)(gextras.NewStructNative(unsafe.Pointer(src[i])))
		}
	}

	return _rrCrtcs
}

// The function returns the following values:
//
func (output *RROutput) PreferredMode() *RRMode {
	var _arg0 *C.GnomeRROutput // out
	var _cret *C.GnomeRRMode   // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_preferred_mode(_arg0)
	runtime.KeepAlive(output)

	var _rrMode *RRMode // out

	_rrMode = (*RRMode)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rrMode
}

// The function returns the following values:
//
func (output *RROutput) IsBuiltinDisplay() bool {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_is_builtin_display(_arg0)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (output *RROutput) ListModes() []*RRMode {
	var _arg0 *C.GnomeRROutput // out
	var _cret **C.GnomeRRMode  // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_list_modes(_arg0)
	runtime.KeepAlive(output)

	var _rrModes []*RRMode // out

	{
		var i int
		var z *C.GnomeRRMode
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_rrModes = make([]*RRMode, i)
		for i := range src {
			_rrModes[i] = (*RRMode)(gextras.NewStructNative(unsafe.Pointer(src[i])))
		}
	}

	return _rrModes
}

// The function takes the following parameters:
//
//   - value: absolute value which is 0 >= this <= 100.
//
func (output *RROutput) SetBacklight(value int) error {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 C.gint           // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))
	_arg1 = C.gint(value)

	C.gnome_rr_output_set_backlight(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(output)
	runtime.KeepAlive(value)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// The function takes the following parameters:
//
func (output *RROutput) SetColorTransform(value *RRCTM) error {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 C.GnomeRRCTM     // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))
	_arg1 = *(*C.GnomeRRCTM)(gextras.StructNative(unsafe.Pointer(value)))

	C.gnome_rr_output_set_color_transform(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(output)
	runtime.KeepAlive(value)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// The function returns the following values:
//
func (output *RROutput) SupportsColorTransform() bool {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_supports_color_transform(_arg0)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (output *RROutput) SupportsMode(mode *RRMode) bool {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 *C.GnomeRRMode   // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))
	_arg1 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_output_supports_mode(_arg0, _arg1)
	runtime.KeepAlive(output)
	runtime.KeepAlive(mode)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (output *RROutput) SupportsUnderscanning() bool {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_supports_underscanning(_arg0)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RRScreenClass: instance of this type is always passed by reference.
type RRScreenClass struct {
	*rrScreenClass
}

// rrScreenClass is the struct that's finalized.
type rrScreenClass struct {
	native *C.GnomeRRScreenClass
}
