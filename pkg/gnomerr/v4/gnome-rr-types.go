// Code generated by girgen. DO NOT EDIT.

package gnomerr

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeCrtc   = coreglib.Type(C.gnome_rr_crtc_get_type())
	GTypeMode   = coreglib.Type(C.gnome_rr_mode_get_type())
	GTypeOutput = coreglib.Type(C.gnome_rr_output_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCrtc, F: marshalCrtc},
		coreglib.TypeMarshaler{T: GTypeMode, F: marshalMode},
		coreglib.TypeMarshaler{T: GTypeOutput, F: marshalOutput},
	})
}

type DpmsMode C.gint

const (
	RrDpmsOn DpmsMode = iota
	RrDpmsStandby
	RrDpmsSuspend
	RrDpmsOff
	RrDpmsUnknown
)

// String returns the name in string for DpmsMode.
func (d DpmsMode) String() string {
	switch d {
	case RrDpmsOn:
		return "On"
	case RrDpmsStandby:
		return "Standby"
	case RrDpmsSuspend:
		return "Suspend"
	case RrDpmsOff:
		return "Off"
	case RrDpmsUnknown:
		return "Unknown"
	default:
		return fmt.Sprintf("DpmsMode(%d)", d)
	}
}

type Rotation C.guint

const (
	RrRotationNext Rotation = 0b0
	RrRotation0    Rotation = 0b1
	RrRotation90   Rotation = 0b10
	RrRotation180  Rotation = 0b100
	RrRotation270  Rotation = 0b1000
	RrReflectX     Rotation = 0b10000
	RrReflectY     Rotation = 0b100000
)

// String returns the names in string for Rotation.
func (r Rotation) String() string {
	if r == 0 {
		return "Rotation(0)"
	}

	var builder strings.Builder
	builder.Grow(89)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RrRotationNext:
			builder.WriteString("RotationNext|")
		case RrRotation0:
			builder.WriteString("Rotation0|")
		case RrRotation90:
			builder.WriteString("Rotation90|")
		case RrRotation180:
			builder.WriteString("Rotation180|")
		case RrRotation270:
			builder.WriteString("Rotation270|")
		case RrReflectX:
			builder.WriteString("ReflectX|")
		case RrReflectY:
			builder.WriteString("ReflectY|")
		default:
			builder.WriteString(fmt.Sprintf("Rotation(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r Rotation) Has(other Rotation) bool {
	return (r & other) == other
}

// CTM: instance of this type is always passed by reference.
type CTM struct {
	*ctM
}

// ctM is the struct that's finalized.
type ctM struct {
	native *C.GnomeRRCTM
}

// Crtc: instance of this type is always passed by reference.
type Crtc struct {
	*crtc
}

// crtc is the struct that's finalized.
type crtc struct {
	native *C.GnomeRRCrtc
}

func marshalCrtc(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Crtc{&crtc{(*C.GnomeRRCrtc)(b)}}, nil
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (crtc *Crtc) CanDriveOutput(output *Output) bool {
	var _arg0 *C.GnomeRRCrtc   // out
	var _arg1 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))
	_arg1 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_crtc_can_drive_output(_arg0, _arg1)
	runtime.KeepAlive(crtc)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - mode: current mode of this crtc.
//
func (crtc *Crtc) CurrentMode() *Mode {
	var _arg0 *C.GnomeRRCrtc // out
	var _cret *C.GnomeRRMode // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))

	_cret = C.gnome_rr_crtc_get_current_mode(_arg0)
	runtime.KeepAlive(crtc)

	var _mode *Mode // out

	_mode = (*Mode)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _mode
}

// The function returns the following values:
//
func (crtc *Crtc) CurrentRotation() Rotation {
	var _arg0 *C.GnomeRRCrtc    // out
	var _cret C.GnomeRRRotation // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))

	_cret = C.gnome_rr_crtc_get_current_rotation(_arg0)
	runtime.KeepAlive(crtc)

	var _rotation Rotation // out

	_rotation = Rotation(_cret)

	return _rotation
}

// The function takes the following parameters:
//
// The function returns the following values:
//
//   - red: minimum width.
//   - green: maximum width.
//   - blue: minimum height.
//   - ok: TRUE for success.
//
func (crtc *Crtc) Gamma(size *int) (red *uint16, green *uint16, blue *uint16, ok bool) {
	var _arg0 *C.GnomeRRCrtc // out
	var _arg1 *C.int         // out
	var _arg2 *C.ushort      // in
	var _arg3 *C.ushort      // in
	var _arg4 *C.ushort      // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))
	_arg1 = (*C.int)(unsafe.Pointer(size))

	_cret = C.gnome_rr_crtc_get_gamma(_arg0, _arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(crtc)
	runtime.KeepAlive(size)

	var _red *uint16   // out
	var _green *uint16 // out
	var _blue *uint16  // out
	var _ok bool       // out

	_red = (*uint16)(unsafe.Pointer(_arg2))
	_green = (*uint16)(unsafe.Pointer(_arg3))
	_blue = (*uint16)(unsafe.Pointer(_arg4))
	if _cret != 0 {
		_ok = true
	}

	return _red, _green, _blue, _ok
}

// The function returns the following values:
//
func (crtc *Crtc) ID() uint32 {
	var _arg0 *C.GnomeRRCrtc // out
	var _cret C.guint32      // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))

	_cret = C.gnome_rr_crtc_get_id(_arg0)
	runtime.KeepAlive(crtc)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// The function returns the following values:
//
//   - x (optional)
//   - y (optional)
//
func (crtc *Crtc) Position() (x int, y int) {
	var _arg0 *C.GnomeRRCrtc // out
	var _arg1 C.int          // in
	var _arg2 C.int          // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))

	C.gnome_rr_crtc_get_position(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(crtc)

	var _x int // out
	var _y int // out

	_x = int(_arg1)
	_y = int(_arg2)

	return _x, _y
}

// The function returns the following values:
//
func (crtc *Crtc) Rotations() Rotation {
	var _arg0 *C.GnomeRRCrtc    // out
	var _cret C.GnomeRRRotation // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))

	_cret = C.gnome_rr_crtc_get_rotations(_arg0)
	runtime.KeepAlive(crtc)

	var _rotation Rotation // out

	_rotation = Rotation(_cret)

	return _rotation
}

// The function takes the following parameters:
//
//   - size
//   - red
//   - green
//   - blue
//
// The function returns the following values:
//
func (crtc *Crtc) SetGamma(size int, red *uint16, green *uint16, blue *uint16) bool {
	var _arg0 *C.GnomeRRCrtc // out
	var _arg1 C.int          // out
	var _arg2 *C.ushort      // out
	var _arg3 *C.ushort      // out
	var _arg4 *C.ushort      // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))
	_arg1 = C.int(size)
	_arg2 = (*C.ushort)(unsafe.Pointer(red))
	_arg3 = (*C.ushort)(unsafe.Pointer(green))
	_arg4 = (*C.ushort)(unsafe.Pointer(blue))

	_cret = C.gnome_rr_crtc_set_gamma(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(crtc)
	runtime.KeepAlive(size)
	runtime.KeepAlive(red)
	runtime.KeepAlive(green)
	runtime.KeepAlive(blue)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (crtc *Crtc) SupportsRotation(rotation Rotation) bool {
	var _arg0 *C.GnomeRRCrtc    // out
	var _arg1 C.GnomeRRRotation // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GnomeRRCrtc)(gextras.StructNative(unsafe.Pointer(crtc)))
	_arg1 = C.GnomeRRRotation(rotation)

	_cret = C.gnome_rr_crtc_supports_rotation(_arg0, _arg1)
	runtime.KeepAlive(crtc)
	runtime.KeepAlive(rotation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Mode: instance of this type is always passed by reference.
type Mode struct {
	*mode
}

// mode is the struct that's finalized.
type mode struct {
	native *C.GnomeRRMode
}

func marshalMode(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Mode{&mode{(*C.GnomeRRMode)(b)}}, nil
}

// The function returns the following values:
//
func (mode *Mode) Freq() int {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.int          // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_freq(_arg0)
	runtime.KeepAlive(mode)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
func (mode *Mode) FreqF() float64 {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.double       // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_freq_f(_arg0)
	runtime.KeepAlive(mode)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// The function returns the following values:
//
func (mode *Mode) Height() uint {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.guint        // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_height(_arg0)
	runtime.KeepAlive(mode)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
func (mode *Mode) ID() uint32 {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.guint32      // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_id(_arg0)
	runtime.KeepAlive(mode)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// The function returns the following values:
//
func (mode *Mode) IsInterlaced() bool {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_is_interlaced(_arg0)
	runtime.KeepAlive(mode)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsTiled returns TRUE if this mode is a tiled mode created for span a tiled
// monitor.
//
// The function returns the following values:
//
func (mode *Mode) IsTiled() bool {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_is_tiled(_arg0)
	runtime.KeepAlive(mode)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (mode *Mode) Width() uint {
	var _arg0 *C.GnomeRRMode // out
	var _cret C.guint        // in

	_arg0 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_mode_get_width(_arg0)
	runtime.KeepAlive(mode)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Output: instance of this type is always passed by reference.
type Output struct {
	*output
}

// output is the struct that's finalized.
type output struct {
	native *C.GnomeRROutput
}

func marshalOutput(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Output{&output{(*C.GnomeRROutput)(b)}}, nil
}

// CanClone checks whether the given output can clone another output.
//
// The function takes the following parameters:
//
//   - clone: output to compare.
//
// The function returns the following values:
//
//   - ok: TRUE if the output can clone another output.
//
func (output *Output) CanClone(clone *Output) bool {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))
	_arg1 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(clone)))

	_cret = C.gnome_rr_output_can_clone(_arg0, _arg1)
	runtime.KeepAlive(output)
	runtime.KeepAlive(clone)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Backlight retrieves the backlight brightness of the given output.
//
// The function returns the following values:
//
//   - gint: currently set backlight brightness.
//
func (output *Output) Backlight() int {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gint           // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_backlight(_arg0)
	runtime.KeepAlive(output)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Crtc retrieves the CRTC of the given output.
//
// The function returns the following values:
//
//   - crtc: CRTC of the output.
//
func (output *Output) Crtc() *Crtc {
	var _arg0 *C.GnomeRROutput // out
	var _cret *C.GnomeRRCrtc   // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_crtc(_arg0)
	runtime.KeepAlive(output)

	var _crtc *Crtc // out

	_crtc = (*Crtc)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _crtc
}

// CurrentMode retrieves the current mode of the given output.
//
// The function returns the following values:
//
//   - mode: current mode of this output.
//
func (output *Output) CurrentMode() *Mode {
	var _arg0 *C.GnomeRROutput // out
	var _cret *C.GnomeRRMode   // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_current_mode(_arg0)
	runtime.KeepAlive(output)

	var _mode *Mode // out

	_mode = (*Mode)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _mode
}

// DisplayName retrieves the display name of the given output.
//
// The function returns the following values:
//
//   - utf8: display name.
//
func (output *Output) DisplayName() string {
	var _arg0 *C.GnomeRROutput // out
	var _cret *C.char          // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_display_name(_arg0)
	runtime.KeepAlive(output)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (output *Output) EdidData(size *uint) *byte {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 *C.gsize         // out
	var _cret *C.guint8        // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))
	_arg1 = (*C.gsize)(unsafe.Pointer(size))

	_cret = C.gnome_rr_output_get_edid_data(_arg0, _arg1)
	runtime.KeepAlive(output)
	runtime.KeepAlive(size)

	var _guint8 *byte // out

	_guint8 = (*byte)(unsafe.Pointer(_cret))

	return _guint8
}

// The function returns the following values:
//
func (output *Output) ID() uint32 {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.guint32        // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_id(_arg0)
	runtime.KeepAlive(output)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// IDsFromEdid retrieves the model identifiers from the EDID of the given
// output.
//
// The function returns the following values:
//
//   - vendor (optional) output's vendor string.
//   - product (optional) output's product string.
//   - serial (optional) output's serial string.
//
func (output *Output) IDsFromEdid() (vendor string, product string, serial string) {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 *C.char          // in
	var _arg2 *C.char          // in
	var _arg3 *C.char          // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	C.gnome_rr_output_get_ids_from_edid(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(output)

	var _vendor string  // out
	var _product string // out
	var _serial string  // out

	if _arg1 != nil {
		_vendor = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if _arg2 != nil {
		_product = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _arg3 != nil {
		_serial = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	return _vendor, _product, _serial
}

// IsPrimary checks whether the given output is the primary output.
//
// The function returns the following values:
//
//   - ok: TRUE if the output is the primary one.
//
func (output *Output) IsPrimary() bool {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_is_primary(_arg0)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (output *Output) IsUnderscanning() bool {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_is_underscanning(_arg0)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MinBacklightStep retrieves the value of the minimum backlight step for the
// given output, as a percentage.
//
// The function returns the following values:
//
//   - gint: minimum backlight step available in percent.
//
func (output *Output) MinBacklightStep() int {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gint           // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_min_backlight_step(_arg0)
	runtime.KeepAlive(output)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Name retrieves the name of the given output.
//
// The function returns the following values:
//
//   - utf8: name of the output.
//
func (output *Output) Name() string {
	var _arg0 *C.GnomeRROutput // out
	var _cret *C.char          // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_name(_arg0)
	runtime.KeepAlive(output)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PhysicalSize retrieves the physical size of the given output.
//
// The function returns the following values:
//
//   - widthMm (optional): width of the output, in millimeters.
//   - heightMm (optional): height of the output, in millimeters.
//
func (output *Output) PhysicalSize() (widthMm int, heightMm int) {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 C.int            // in
	var _arg2 C.int            // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	C.gnome_rr_output_get_physical_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(output)

	var _widthMm int  // out
	var _heightMm int // out

	_widthMm = int(_arg1)
	_heightMm = int(_arg2)

	return _widthMm, _heightMm
}

// The function returns the following values:
//
//   - x (optional): x coordinate of the output.
//   - y (optional): y coordinate of the output.
//
func (output *Output) Position() (x int, y int) {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 C.int            // in
	var _arg2 C.int            // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	C.gnome_rr_output_get_position(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(output)

	var _x int // out
	var _y int // out

	_x = int(_arg1)
	_y = int(_arg2)

	return _x, _y
}

// PossibleCrtcs retrieves all the possible CRTC for the given output.
//
// The function returns the following values:
//
//   - crtcs: list of possible CRTC.
//
func (output *Output) PossibleCrtcs() []*Crtc {
	var _arg0 *C.GnomeRROutput // out
	var _cret **C.GnomeRRCrtc  // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_possible_crtcs(_arg0)
	runtime.KeepAlive(output)

	var _crtcs []*Crtc // out

	{
		var i int
		var z *C.GnomeRRCrtc
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_crtcs = make([]*Crtc, i)
		for i := range src {
			_crtcs[i] = (*Crtc)(gextras.NewStructNative(unsafe.Pointer(src[i])))
		}
	}

	return _crtcs
}

// PreferredMode retrieves the preferred mode of the given output.
//
// The function returns the following values:
//
//   - mode: preferred mode of the output.
//
func (output *Output) PreferredMode() *Mode {
	var _arg0 *C.GnomeRROutput // out
	var _cret *C.GnomeRRMode   // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_get_preferred_mode(_arg0)
	runtime.KeepAlive(output)

	var _mode *Mode // out

	_mode = (*Mode)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _mode
}

// IsBuiltinDisplay checks whether the given output is a built-in display.
//
// The function returns the following values:
//
//   - ok: TRUE if the output is a built-in display.
//
func (output *Output) IsBuiltinDisplay() bool {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_is_builtin_display(_arg0)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListModes retrieves all available modes of the given output.
//
// The function returns the following values:
//
//   - modes: list of modes.
//
func (output *Output) ListModes() []*Mode {
	var _arg0 *C.GnomeRROutput // out
	var _cret **C.GnomeRRMode  // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_list_modes(_arg0)
	runtime.KeepAlive(output)

	var _modes []*Mode // out

	{
		var i int
		var z *C.GnomeRRMode
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_modes = make([]*Mode, i)
		for i := range src {
			_modes[i] = (*Mode)(gextras.NewStructNative(unsafe.Pointer(src[i])))
		}
	}

	return _modes
}

// SetBacklight sets the backlight level for the given output.
//
// The value is a percentage, with a range of [0, 100].
//
// The function takes the following parameters:
//
//   - value: absolute value of the backlight.
//
func (output *Output) SetBacklight(value int) error {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 C.int            // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))
	_arg1 = C.int(value)

	C.gnome_rr_output_set_backlight(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(output)
	runtime.KeepAlive(value)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetColorTransform sets the color transformation matrix for the given output.
//
// The function takes the following parameters:
//
//   - ctm: color transformation matrix.
//
func (output *Output) SetColorTransform(ctm *CTM) error {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 C.GnomeRRCTM     // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))
	_arg1 = *(*C.GnomeRRCTM)(gextras.StructNative(unsafe.Pointer(ctm)))

	C.gnome_rr_output_set_color_transform(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(output)
	runtime.KeepAlive(ctm)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// The function returns the following values:
//
func (output *Output) SupportsColorTransform() bool {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_supports_color_transform(_arg0)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsMode checks whether the given output supports a mode.
//
// The function takes the following parameters:
//
//   - mode to compare.
//
// The function returns the following values:
//
//   - ok: TRUE if the mode is supported.
//
func (output *Output) SupportsMode(mode *Mode) bool {
	var _arg0 *C.GnomeRROutput // out
	var _arg1 *C.GnomeRRMode   // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))
	_arg1 = (*C.GnomeRRMode)(gextras.StructNative(unsafe.Pointer(mode)))

	_cret = C.gnome_rr_output_supports_mode(_arg0, _arg1)
	runtime.KeepAlive(output)
	runtime.KeepAlive(mode)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (output *Output) SupportsUnderscanning() bool {
	var _arg0 *C.GnomeRROutput // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GnomeRROutput)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gnome_rr_output_supports_underscanning(_arg0)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
